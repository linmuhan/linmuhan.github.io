<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《Dubbo》接入与调用原理解析</title>
      <link href="/2020/11/19/%E3%80%8ADubbo%E3%80%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/11/19/%E3%80%8ADubbo%E3%80%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在学习Dubbo的时候可以发现，Dubbo的实现原理很多，但是接入的方式简单且多样。就像一个接口的服务暴露，我们并不需要去关心如何实现暴露，因为Dubbo已经帮我们实现了并且隐藏。用户只需要关注以下的内容就行：</p><ul><li>关注业务场景，编写面向接口的业务代码</li><li>少量的启动配置，比如配置中心和暴露的协议等</li></ul><p>虽然Dubbo帮我们实现封装了那么多，让用户无须去关心实现底层。但是如果是为了学习，还是要自己深入去了解的。关于Dubbo的接入方式主要有基于XML的配置实现，基于注解的实现，基于API的实现。但是在演示代码之前也是要先了解Dubbo的一些基础知识。</p><h3 id="Dubbo功能与角色简介"><a href="#Dubbo功能与角色简介" class="headerlink" title="Dubbo功能与角色简介"></a>Dubbo功能与角色简介</h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ol><li>Remoting：远程通讯，提供对多种 NIO 框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。</li><li>Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li>Registry：服务注册中心，服务自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ol><h4 id="组件角色"><a href="#组件角色" class="headerlink" title="组件角色"></a>组件角色</h4><p>关于Dubbo的组件主要角色，官网给的图片最能体现角色的职责与位置。</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210429001305.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210429001305.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><table><thead><tr><th align="left">组件角色</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Provider</td><td align="left">暴露服务的服务提供方</td></tr><tr><td align="left">Consumer</td><td align="left">调用远程服务的服务消费方</td></tr><tr><td align="left">Registry</td><td align="left">服务注册与发现的注册中心</td></tr><tr><td align="left">Monitor</td><td align="left">统计服务的调用次调和调用时间的监控中心</td></tr><tr><td align="left">Container</td><td align="left">服务运行容器</td></tr></tbody></table><p>这里通过一个比较详细的流程图再次了解，执行顺序依然参考上方官方图。</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210429001513.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210429001513.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="基于XML配置实现"><a href="#基于XML配置实现" class="headerlink" title="基于XML配置实现"></a>基于XML配置实现</h3><p>Dubbo的接入可以通过XML配置进行实现，这也是dubbo用的比较多的一种方式。通过XML配置进行对外接口的暴露，可以让我们将dubbo与业务代码尽可能少的耦合在一起，并且修改底层代码时候，并不需要改变和编译代码。</p><p><strong>暴露的服务接口</strong></p><p>我们把api抽取模块，这里演示只需要一个提供接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin.dubbo.samples.echo.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EchoService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//打算暴露的接口</span></span><br><span class="line">    <span class="function">String <span class="title">echo</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要有两个模块，一个provider模块，用来提供服务的实现和暴露。一个consumer模块，用来远程调用服务。需要注意的是，我们在两个模块里面是需要api模块依赖的。</p><p><strong>provider模块</strong></p><p>我们在生产者模块这里，主要需要做的是有实现api接口，通过xml配置文件配置dubbo和服务接口相关信息，需要一个main方法来加载容器和配置文件。</p><p>（1）实现api接口</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210430153808.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210430153808.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>（2）XML配置文件</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210430154015.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210430154015.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>（3）生产者服务提供</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210430154225.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210430154225.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><strong>consumser模块</strong></p><p>（1）XML配置文件指定服务消费和注册服务中心</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210430154556.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210430154556.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>（2）服务消费者消费</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210430155034.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210430155034.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><strong>输出</strong></p><p>我们需要先启动服务生产者之后才能再启动服务消费者，在消费者启动之后就可以看到两边的输出结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生产者输出结果</span></span><br><span class="line">[15:53:21] Hello Hello World and CryFace !, request from consumer: /192.168.87.1:51797</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 消费者输出结果</span></span><br><span class="line">echo result: Hello World and CryFace !</span><br></pre></td></tr></table></figure><h3 id="基于注解实现"><a href="#基于注解实现" class="headerlink" title="基于注解实现"></a>基于注解实现</h3><p>基于注解接入dubbo我们就可以消除XML配置了，这种方式比较友好，但是与此同时也带来了业务代码耦合了一些Dubbo框架注解。</p><p>依然是我们的两个模块都需要引入api模块依赖。</p><p><strong>provider模块</strong></p><p>（1）服务接口实现</p><p>在我们provider里面，依旧要实现接口类。代码和上面实现一样，不过不同的是，我们需要在类上面加一个@Service注解，用来暴露服务接口。要注意的是这个@Service注解引入的是dubbo的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServiceImpl</span> <span class="keyword">implements</span> <span class="title">EchoService</span> </span>&#123;...实现同上...&#125;</span><br></pre></td></tr></table></figure><p>（2）服务生产者提供</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210430165450.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210430165450.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><strong>consumer模块</strong></p><p>（1）消费包装</p><p>消费者这边我们主要通过@Reference注解来实现远程调用，但是需要注意的是该字段适用于对象字段和方法中，所以通过一个消费包装类来包装消费。</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210430165928.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210430165928.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>（2）服务消费者调用</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210430170646.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210430170646.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><strong>输出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> provider</span></span><br><span class="line">[17:07:20] Hello Hello world!, request from consumer: /192.168.87.1:51526</span><br><span class="line"><span class="meta">#</span><span class="bash"> consumer</span></span><br><span class="line">result: Hello world!</span><br></pre></td></tr></table></figure><h3 id="基于API实现"><a href="#基于API实现" class="headerlink" title="基于API实现"></a>基于API实现</h3><p>虽然说Dubbo大部分应用场景都是与Spring中使用，使用的比较多也是XML和注解方式。但是还是需要提一下的是，Dubbo还支持API的方式。API的方式使用场景很少，不过某些特殊情况下还是很有用的。比如进行网关类的应用，需要动态消费不同版本的服务，通过API，可以根据前端请求参数动态构造不同版本的服务实例。</p><p><strong>provider</strong></p><p>（1）服务实现类</p><p>基于注解的实现去掉@Service。</p><p>（2）服务生产提供</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210430172715.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210430172715.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><strong>consumer</strong></p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210430172844.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210430172844.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><strong>输出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生产者</span></span><br><span class="line">java-echo-provider is running</span><br><span class="line">[17:27:59] Hello Hello world!, request from consumer: /192.168.87.1:55621</span><br><span class="line"><span class="meta">#</span><span class="bash"> 消费者</span></span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure><h3 id="Dubbo服务调用流程"><a href="#Dubbo服务调用流程" class="headerlink" title="Dubbo服务调用流程"></a>Dubbo服务调用流程</h3><p>在Dubbo的代码中，我们可以看到一个完整的服务暴露，服务消费的流程。但是内部的流程是怎么样的呢，我们能知道吗？Dubbo的各个组件在什么地方又扮演了什么角色？</p><h4 id="Dubbo基本分层"><a href="#Dubbo基本分层" class="headerlink" title="Dubbo基本分层"></a>Dubbo基本分层</h4><p>在Dubbo的架构里面总体分为了业务层（Biz）、RPC层、Remote三层。继续细分的话可以分为十层，每一层又有自己重要的实现接口如右。</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210501224618.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210501224618.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="原书图片"></p><p>关于每一层的介绍，官网和更多详细书籍都有介绍，这里我用自己的话简述一下。</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210501235211.jpg" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210501235211.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h4 id="服务调用流程"><a href="#服务调用流程" class="headerlink" title="服务调用流程"></a>服务调用流程</h4><p>在了解上面那些组件之后，我们再来看服务调用过程，就能比较清楚的认识到这些组件在整个服务调用流程中具体扮演了什么角色。</p><p><strong>服务暴露</strong></p><p>我们的服务暴露是在服务提供者中进行的，在框架启动的时候，开始进行整个流程。</p><ol><li><p>首先会初始化我们的API实现接口的实例。</p></li><li><p>然后通过我们的Proxy组件去调用具体协议（Protocol），也就是加载我们的配置然后进行封装。</p></li><li><p>将服务端要暴露的接口封装成Invoker（可执行体），然后再封装成Exporter（再次封装是为了接口增强，主要是打开创建一个Netty Server 侦听服务，并接收客户端发来的各种请求）。这两个接口在上面图中也可以知道，其实都是Protocol下的接口。</p></li><li><p>然后通过Registry注册到注册中心，这便是一个整体的服务暴露过程。</p></li></ol><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210502002746.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210502002746.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><strong>服务调用总流程</strong></p><p>（1）在Provider的服务暴露之后，我们的Consumer的调用流程也是从一个Proxy开始，Proxy持有Invoker对象，然后触发invoke调用。</p><p>（2）然后获取节点需要通过我们的Cluster，上面组件作用也说过了通过它的作用，主要是负责一些容错。在调用之前会先通过Directory获取所有可以调用的远程服务Invoker列表。如果配置了某些路由规则，比如某个接口只能调用某个节点的那就再过滤一遍 Invoker 列表。</p><p>（3）剩下的 Invoker 再通过 LoadBalance 做负载均衡选取一个，然后再通过Filter进行一些计数，限流，处理上下文之类的操作等。</p><p>（4）这个时候我们已经拿到了一个实际可用的Invoker，然后会使用Client做数据传输，比如常见的Netty Client。</p><p>（5）Codec接口主要是用来处理一些私有协议的构造。构造完成后，进行序列化，然后传输到服务提供者端，服务提供者收到数据包之后，处理协议，反序列化等等操作。</p><p>（6）序列化操作完之后我们的请求就被打到线程池去处理，然后查找对应的Exporter（内部持有Invoker），然后将装饰器模式嵌套了一层又一层的Filter剥掉，还原到一个原始的Invoker再到一个真实的服务接口实现类。最后将这个实现类真实调用并原路返回就行。</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210502012237.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210502012237.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h4 id="服务调用流程总结"><a href="#服务调用流程总结" class="headerlink" title="服务调用流程总结"></a>服务调用流程总结</h4><p>关于服务调用的大概流程基本如上，但是也仅限认识了大概流程。具体每个组件的实现细节，哪些巧妙的地方还是无从而知，所以这些仍是需要我们去学习的地方的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p>[1] 《深入理解Apache Dubbo与实战》</p><p>[2] <a href="https://dubbo.apache.org/zh/docs/v2.7/user/quick-start/">https://dubbo.apache.org/zh/docs/v2.7/user/quick-start/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《模版方法》——设计模式</title>
      <link href="/2020/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>模式方法是设计模式里面比较好理解的一个设计模式，它的定义是：<code>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</code></p><p>模版方法模式的结构很简单，仅仅使用了Java的继承机制，应用十分广泛！</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210815232043.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210815232043.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>同样的，虽然该模式很好理解，但是为了加深理解，我们还是用例子来举例，更容易记住这个模式！</p><p>我们以泡茶这个流程为例来说明。我们可以简单的定义一下泡茶的流程（并非标准流程）：</p><ol><li>首先将水煮沸</li><li>将我们要泡的茶的茶叶放入杯中</li><li>倒入我们的沸水，即可以饮用</li></ol><p>这里我们总共有三个流程，不管是泡什么茶叶基本流程都是这样，区别就是在第二步放入的茶叶不同，而其他步骤是一样的。那我们完全可以将其他重复的步骤提取出来复用！下面我们用代码来实现一下可以更好的理解</p><p>首先是我们的泡茶抽象类（MakeTea）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeTea</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义为final型，我们的子类是不可以修改泡茶的具体顺序的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>&#123;</span><br><span class="line">        boilingWater();</span><br><span class="line">        addTeaLeaf();</span><br><span class="line">        pourBoilingWater();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    首先是我们的将开水煮沸</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boilingWater</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;首先将开水煮沸！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    加入我们的茶叶，定义为抽象类，由我们的子类来实现加入什么具体的茶叶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addTeaLeaf</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    倒入我们的沸水，开始饮用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourBoilingWater</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒入我们的沸水，可以饮用了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们是去泡一杯铁观音（TieGuanYin）和碧螺春（BiLouChun）试试！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> template;</span><br><span class="line"></span><br><span class="line"><span class="comment">//铁观音茶</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TieGuanYin</span> <span class="keyword">extends</span> <span class="title">MakeTea</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTeaLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加入了铁观音茶叶！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> template;</span><br><span class="line"></span><br><span class="line"><span class="comment">//碧螺春茶</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiLouChun</span> <span class="keyword">extends</span> <span class="title">MakeTea</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTeaLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加入碧螺春茶叶！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在客户端测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化我们的两种茶</span></span><br><span class="line">        MakeTea tieGuanYin = <span class="keyword">new</span> TieGuanYin();</span><br><span class="line">        MakeTea biLouChun = <span class="keyword">new</span> BiLouChun();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//制作铁观音</span></span><br><span class="line">        tieGuanYin.make();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------分割线------------&quot;</span>);</span><br><span class="line">        <span class="comment">//制作碧螺春</span></span><br><span class="line">        biLouChun.make();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先将开水煮沸！</span><br><span class="line">加入了铁观音茶叶！</span><br><span class="line">倒入我们的沸水，可以饮用了！</span><br><span class="line">------------分割线------------</span><br><span class="line">首先将开水煮沸！</span><br><span class="line">加入碧螺春茶叶！</span><br><span class="line">倒入我们的沸水，可以饮用了！</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure><p>可以看到我们基本都不用重新再去实现原来的步骤，只是在第二步换了我们添加的茶叶，极大提高了我们代码的复用性。但是呢，同时有一个问题，如果我们不想加入茶叶了呢，茶喝多了，想喝点开水。可以看到我们只需要第二步不加入茶叶就是开水了，所有就有了<strong>钩子</strong>来让用户是否实现抽象方法！</p><h3 id="实现钩子"><a href="#实现钩子" class="headerlink" title="实现钩子"></a>实现钩子</h3><p>钩子是一种被声明在抽象类中的方法，但只有空的或者默认的实现。这里我们就可以用钩子来实现用户是否选择要加入茶叶，如果不加入茶叶的，就是白开水了。</p><p>我们在我们的泡茶抽象类添加钩子方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeTea</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义为final型，我们的子类是不可以修改泡茶的具体顺序的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>&#123;</span><br><span class="line">        boilingWater();</span><br><span class="line">        <span class="keyword">if</span>(isAddTeaLeaf())&#123;  <span class="comment">//如果为true,我们就进行添加茶叶的操作</span></span><br><span class="line">            addTeaLeaf();</span><br><span class="line">        &#125;</span><br><span class="line">        pourBoilingWater();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    首先是我们的将开水煮沸</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boilingWater</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;首先将开水煮沸！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    加入我们的茶叶，定义为抽象类，由我们的子类来实现加入什么具体的茶叶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addTeaLeaf</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    倒入我们的沸水，开始饮用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourBoilingWater</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒入我们的沸水，可以饮用了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    钩子方法，判断用户是否要加入茶叶,默认为添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAddTeaLeaf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后去实现一杯白开水，然后重写钩子方法，改为false，就可以跳过我们的添加茶叶操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoiledWater</span> <span class="keyword">extends</span> <span class="title">MakeTea</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTeaLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空实现，因为白开水不需要添加茶叶哦！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAddTeaLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//返回false，表示我们不添加茶叶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在我们的客户端是实例化，并不影响我们之前的茶，而且也成功了泡了一杯白开水！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化我们的两种茶</span></span><br><span class="line">        MakeTea tieGuanYin = <span class="keyword">new</span> TieGuanYin();</span><br><span class="line">        MakeTea biLouChun = <span class="keyword">new</span> BiLouChun();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//制作铁观音</span></span><br><span class="line">        tieGuanYin.make();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------分割线------------&quot;</span>);</span><br><span class="line">        <span class="comment">//制作碧螺春</span></span><br><span class="line">        biLouChun.make();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------分割线------------&quot;</span>);</span><br><span class="line">        <span class="comment">//制作一杯白开水</span></span><br><span class="line">        MakeTea boiledWater = <span class="keyword">new</span> BoiledWater();</span><br><span class="line">        boiledWater.make();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">首先将开水煮沸！</span><br><span class="line">加入了铁观音茶叶！</span><br><span class="line">倒入我们的沸水，可以饮用了！</span><br><span class="line">------------分割线------------</span><br><span class="line">首先将开水煮沸！</span><br><span class="line">加入碧螺春茶叶！</span><br><span class="line">倒入我们的沸水，可以饮用了！</span><br><span class="line">------------分割线------------</span><br><span class="line">首先将开水煮沸！</span><br><span class="line">倒入我们的沸水，可以饮用了！</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>模版方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</strong></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>封装不变部分，扩展可变部分</li><li>提取公共部分代码，便于维护</li><li>行为由父类控制，子类实现，符合开闭原则</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>颠倒了我们的设计习惯，一般是抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的食物属性和方法；但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目<br>中，会带来代码阅读的难度，而且也会让新手产生不适感。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>多个子类共有的方法，并且逻辑基本相同</li><li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个<br>子类实现。</li><li>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通<br>过钩子函数约束其行为。</li></ul><h3 id="（补充）"><a href="#（补充）" class="headerlink" title="（补充）"></a>（补充）</h3><p>模板方法还是父类调用子类方法一个比较好选择，而且在项目中也是符合我们的设计原则的。具体可以参考这一篇<a href="https://www.jianshu.com/p/204e5d76ec11">【Java面试】父类能调用子类的方法吗？</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>设计模式之禅（第二版）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DesignPattern </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《工厂模式》——设计模式</title>
      <link href="/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>工厂模式顾名思义，工厂就是用来统一创建产品的。我们的工厂根据产品是具体产品还是工厂可以分为简单工厂模式和工厂方法模式，根据抽象程度可以分为工厂方法模式和抽象工厂模式。工厂模式的核心本质是：</p><ul><li>实例化对象不使用new，用工厂方法替代</li><li>将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</li></ul><p>工厂模式在我们的场景中用到的还是比较多的：</p><blockquote><ul><li>JDK中Calendar的getInstance方法</li><li>JDBC中的Connection对象的获取</li><li>Spring中IOC容器创建管理bean对象</li><li>反射中Class对象的newInstance方法</li></ul></blockquote><h2 id="简单工厂模式（静态工厂模式）"><a href="#简单工厂模式（静态工厂模式）" class="headerlink" title="简单工厂模式（静态工厂模式）"></a>简单工厂模式（静态工厂模式）</h2><p>用来生产同一等级结构中的任意产品，只需要对工厂传递需要创建对象的类型即可。这里我们以计算器为来讲解该模式：</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210817234039.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210817234039.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>首先是我们的运算统一接口（Operation）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算统一接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加法操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddOperation</span> <span class="keyword">implements</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行了加法操作！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减法操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubOperation</span> <span class="keyword">implements</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行了减法操作！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个简单工厂来代替我们创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpetationFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperate</span><span class="params">(String operate)</span></span>&#123;</span><br><span class="line">        Operation oper = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operate)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;加法&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> AddOperation();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;减法&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> SubOperation();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在客户端进行实践一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个操作执行加法操作</span></span><br><span class="line">        Operation operation1 = OpetationFactory.createOperate(<span class="string">&quot;加法&quot;</span>);</span><br><span class="line">        operation1.operate();</span><br><span class="line">        <span class="comment">//第二个操作执行减法操作</span></span><br><span class="line">        Operation operation2 = OpetationFactory.createOperate(<span class="string">&quot;减法&quot;</span>);</span><br><span class="line">        operation2.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示结果</span></span><br><span class="line"><span class="comment">//进行了加法操作！</span></span><br><span class="line"><span class="comment">//进行了减法操作！</span></span><br></pre></td></tr></table></figure><p>这样我们就不需要创建对象这个过程，只需要告诉工厂我们需要什么对象就行，省略了很多的麻烦。但是如果我们这个时候要增加一个要求怎么办呢？我们先需要实现操作统一接口，然后再在工厂里面增加我们的新操作的分支，比如我们增加一个乘法的操作的话。</p><p>实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulOperation</span> <span class="keyword">implements</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行了乘法操作！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在工厂里面添加分支：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpetationFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperate</span><span class="params">(String operate)</span></span>&#123;</span><br><span class="line">        Operation oper = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operate)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;加法&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> AddOperation();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;减法&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> SubOperation();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;乘法&quot;</span>: <span class="comment">//新加的乘法操作分支</span></span><br><span class="line">                oper = <span class="keyword">new</span> MulOperation();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，这样的操作如果在工程量特别大的去修改代码是特别麻烦的，而且主要的是，这不符合我们的开闭原则（对修改关闭，对扩展开放）。</p><p>所以我们是有办法来关闭修改操作的——<strong>反射</strong>，下面代码我们对创建工厂进行重构之后（T表示只要实现了Operaton都可以当作接口，是JDK1.5之后的新特性——泛型，减少了对象之间的转换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpetationFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Operation&gt; <span class="function">T <span class="title">createOperate</span><span class="params">(Class&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">        Operation oper = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            oper = (T) Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有该操作！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候如果需要添加新的操作的时候，我们只需要创建实现类即可，然后在客户端就可以使用了，关闭了对创建工厂的修改。符合了我们的开闭原则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个操作执行加法操作</span></span><br><span class="line">        Operation operation1 = OpetationFactory.createOperate(AddOperation.class);</span><br><span class="line">        operation1.operate();</span><br><span class="line">        <span class="comment">//第二个操作执行减法操作</span></span><br><span class="line">        Operation operation2 = OpetationFactory.createOperate(SubOperation.class);</span><br><span class="line">        operation2.operate();</span><br><span class="line">        <span class="comment">//第三个操作为我们的乘法操作</span></span><br><span class="line">        Operation operation3 = OpetationFactory.createOperate(MulOperation.class);</span><br><span class="line">        operation3.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进行了加法操作！</span><br><span class="line">进行了减法操作！</span><br><span class="line">进行了乘法操作！</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>对简单工厂模式的优化还有其他方式，可以看看这篇博客<a href="https://www.cnblogs.com/invoker-/p/7684913.html">Java简单工厂模式以及来自lambda的优化</a></p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法是对简单工厂模式进一步的修改，是在不修改已有类的前提下，通过增加新的工厂类实现扩展。可以说是对没有优化前的简单工厂模式的一种优化，贴合了开闭原则。</p><p>我们通过UML图可以清晰认识：</p><p><img src="https://gitee.com/cryface/blog-image/raw/master/20210817234058.png" class="lazyload" data-srcset="https://gitee.com/cryface/blog-image/raw/master/20210817234058.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>我们操作的接口和实现类不变，只不过我们把原来在一个工厂生产对象的的工厂变成了每一个实现类都有自己的生产工厂了。这样我们如果需要再添加新的操作的话，我们只需要添加一个实现类和一个工厂就行了，非常符合我们的开闭原则。</p><p><strong>定义我们工厂统一接口的抽象类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂统一接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OperationFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Operation <span class="title">doingOperate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>然后是我们加法的工厂：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddOperationFactory</span> <span class="keyword">implements</span> <span class="title">OperationFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">doingOperate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AddOperation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>减法的工厂：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubOperationFactory</span> <span class="keyword">implements</span> <span class="title">OperationFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">doingOperate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SubOperation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们的客户端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        OperationFactory factoryAdd = <span class="keyword">new</span> AddOperationFactory();</span><br><span class="line">        OperationFactory factorySub = <span class="keyword">new</span> SubOperationFactory();</span><br><span class="line">        <span class="comment">// 第一个操作为加法操作</span></span><br><span class="line">        Operation operation1 = factoryAdd.doingOperate();</span><br><span class="line">        operation1.operate();   <span class="comment">//输出：进行了加法操作</span></span><br><span class="line">        <span class="comment">// 第二个操作为减法操作</span></span><br><span class="line">        Operation operation2 = factorySub.doingOperate();</span><br><span class="line">        operation2.operate();  <span class="comment">//输出：进行了减法操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂总的来说，<strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</strong>就是围绕一个超级工厂来创建其他工厂，该超级工厂又称为其他工厂的工厂。</p><p>这里我再以计算器的操作来举例有点不合适，网上最多的就是手机和电脑品牌的举例。因为可以比较清晰理解抽象工厂，我们不是增加一个产品，而是增加一个产品族。如果我们只是单一的一个手机可以使用上面的工厂方法来创建，但是如果多了一个电脑呢？可以复制一下手机工厂方法的代码，修改一下名字就可以使用，但是这很明显的就是重复代码了吧。我们是无论如何也不能忍受的，所以就有了抽象工厂模式。</p><p><strong>首先我们先来定义一个手机的统一接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现华为和小米的Phone实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产的是华为手机！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产的是小米手机！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义一个电脑的统一接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现华为和小米的Computer实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiComputer</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产的是华为电脑！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiComputer</span> <span class="keyword">implements</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产的是小米电脑！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是我们的抽象工厂了，因为我们不管是小米工厂还是华为工厂都需要生产手机和电脑，所以我们可以说这就是一个产品族。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Phone <span class="title">makePhone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Computer <span class="title">makeComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们实现抽象工厂的接口，有小米工厂和华为工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaoMiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">makeComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaoMiComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaWeiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">makeComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaWeiComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的客户端使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractFactory xiaoMiFactory = <span class="keyword">new</span> XiaoMiFactory();</span><br><span class="line">        Phone xiaoMiPhone = xiaoMiFactory.makePhone();</span><br><span class="line">        xiaoMiPhone.makePhone();  <span class="comment">//输出：生产的是小米手机！</span></span><br><span class="line">        Computer xiaoMiComputer = xiaoMiFactory.makeComputer();</span><br><span class="line">        xiaoMiComputer.makeComputer(); <span class="comment">//输出：生产的是小米电脑！</span></span><br><span class="line"></span><br><span class="line">        AbstractFactory huaWeiFactory = <span class="keyword">new</span> HuaWeiFactory();</span><br><span class="line">        Phone huaWeiPhone = huaWeiFactory.makePhone();</span><br><span class="line">        huaWeiPhone.makePhone(); <span class="comment">// 输出：生产的是华为手机！</span></span><br><span class="line">        Computer huaWeiComputer = huaWeiFactory.makeComputer();</span><br><span class="line">        huaWeiComputer.makeComputer(); <span class="comment">//输出：生产的是华为电脑！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于我们的抽象工厂的适用场景：</strong></p><ul><li>客户端不依赖产品类实例如何被创建，实现等细节</li><li>强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码</li><li>提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现</li></ul><p><strong>优点：</strong></p><ul><li>具体产品在应用层的代码隔离，无需关心创建的细节</li><li>将一个系列的产品统一到一起创建</li></ul><p><strong>缺点：</strong></p><ul><li>规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难（注意是产品扩展族而不是产品等级。比如我们这个时候要添加一个一加品牌，只要拥有相同的产品簇，我们只要实现产品接口有实现类然后添加一个工厂生产实例就可以实现。可以说是横向扩展，符合开闭原则。但是如果这时候要添加一个充电宝的产品，就需要修改里面的大量代码，极其复杂，所以需要在刚开始就要设计好。）</li><li>增加了系统的抽象性和理解难度</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工厂模式的三种模式有各自的应用场景，无论哪种模式，只要能解决问题就是好用的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>《大话设计模式》</p><p>《设计模式之禅（第二版）》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DesignPattern </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
