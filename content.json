{"meta":{"title":"CryFace","subtitle":"cryface's blog","description":"Forever be humble","author":"CryFace","url":"http://www.cryface.cn","root":"/"},"pages":[{"title":"","date":"2021-08-21T06:30:56.338Z","updated":"2021-08-01T11:39:02.056Z","comments":true,"path":"friends/index.html","permalink":"http://www.cryface.cn/friends/index.html","excerpt":"","text":""},{"title":"","date":"2021-08-21T06:30:56.331Z","updated":"2021-08-01T11:26:14.523Z","comments":true,"path":"404.html","permalink":"http://www.cryface.cn/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-08-21T06:30:56.333Z","updated":"2021-08-01T11:41:26.033Z","comments":false,"path":"artitalk/index.html","permalink":"http://www.cryface.cn/artitalk/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-08-21T06:30:56.335Z","updated":"2021-08-01T11:24:29.468Z","comments":true,"path":"categories/index.html","permalink":"http://www.cryface.cn/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-08-21T06:30:56.339Z","updated":"2021-08-01T11:25:21.555Z","comments":true,"path":"tags/index.html","permalink":"http://www.cryface.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《Dubbo》接入与调用原理解析","slug":"《Dubbo》接入与调用原理解析","date":"2020-11-19T14:13:00.000Z","updated":"2021-08-22T16:15:22.750Z","comments":true,"path":"2020/11/19/《Dubbo》接入与调用原理解析/","link":"","permalink":"http://www.cryface.cn/2020/11/19/%E3%80%8ADubbo%E3%80%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言在学习Dubbo的时候可以发现，Dubbo的实现原理很多，但是接入的方式简单且多样。就像一个接口的服务暴露，我们并不需要去关心如何实现暴露，因为Dubbo已经帮我们实现了并且隐藏。用户只需要关注以下的内容就行： 关注业务场景，编写面向接口的业务代码 少量的启动配置，比如配置中心和暴露的协议等 虽然Dubbo帮我们实现封装了那么多，让用户无须去关心实现底层。但是如果是为了学习，还是要自己深入去了解的。关于Dubbo的接入方式主要有基于XML的配置实现，基于注解的实现，基于API的实现。但是在演示代码之前也是要先了解Dubbo的一些基础知识。 Dubbo功能与角色简介主要功能 Remoting：远程通讯，提供对多种 NIO 框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。 Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 Registry：服务注册中心，服务自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 组件角色关于Dubbo的组件主要角色，官网给的图片最能体现角色的职责与位置。 组件角色 说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次调和调用时间的监控中心 Container 服务运行容器 这里通过一个比较详细的流程图再次了解，执行顺序依然参考上方官方图。 基于XML配置实现Dubbo的接入可以通过XML配置进行实现，这也是dubbo用的比较多的一种方式。通过XML配置进行对外接口的暴露，可以让我们将dubbo与业务代码尽可能少的耦合在一起，并且修改底层代码时候，并不需要改变和编译代码。 暴露的服务接口 我们把api抽取模块，这里演示只需要一个提供接口。 123456package com.lin.dubbo.samples.echo.api;public interface EchoService &#123; //打算暴露的接口 String echo(String message);&#125; 我们需要有两个模块，一个provider模块，用来提供服务的实现和暴露。一个consumer模块，用来远程调用服务。需要注意的是，我们在两个模块里面是需要api模块依赖的。 provider模块 我们在生产者模块这里，主要需要做的是有实现api接口，通过xml配置文件配置dubbo和服务接口相关信息，需要一个main方法来加载容器和配置文件。 （1）实现api接口 （2）XML配置文件 （3）生产者服务提供 consumser模块 （1）XML配置文件指定服务消费和注册服务中心 （2）服务消费者消费 输出 我们需要先启动服务生产者之后才能再启动服务消费者，在消费者启动之后就可以看到两边的输出结果。 12345# 生产者输出结果[15:53:21] Hello Hello World and CryFace !, request from consumer: /192.168.87.1:51797# 消费者输出结果echo result: Hello World and CryFace ! 基于注解实现基于注解接入dubbo我们就可以消除XML配置了，这种方式比较友好，但是与此同时也带来了业务代码耦合了一些Dubbo框架注解。 依然是我们的两个模块都需要引入api模块依赖。 provider模块 （1）服务接口实现 在我们provider里面，依旧要实现接口类。代码和上面实现一样，不过不同的是，我们需要在类上面加一个@Service注解，用来暴露服务接口。要注意的是这个@Service注解引入的是dubbo的。 1234import com.alibaba.dubbo.config.annotation.Service;@Servicepublic class EchoServiceImpl implements EchoService &#123;...实现同上...&#125; （2）服务生产者提供 consumer模块 （1）消费包装 消费者这边我们主要通过@Reference注解来实现远程调用，但是需要注意的是该字段适用于对象字段和方法中，所以通过一个消费包装类来包装消费。 （2）服务消费者调用 输出 1234# provider[17:07:20] Hello Hello world!, request from consumer: /192.168.87.1:51526# consumerresult: Hello world! 基于API实现虽然说Dubbo大部分应用场景都是与Spring中使用，使用的比较多也是XML和注解方式。但是还是需要提一下的是，Dubbo还支持API的方式。API的方式使用场景很少，不过某些特殊情况下还是很有用的。比如进行网关类的应用，需要动态消费不同版本的服务，通过API，可以根据前端请求参数动态构造不同版本的服务实例。 provider （1）服务实现类 基于注解的实现去掉@Service。 （2）服务生产提供 consumer 输出 12345# 生产者java-echo-provider is running[17:27:59] Hello Hello world!, request from consumer: /192.168.87.1:55621# 消费者Hello world! Dubbo服务调用流程在Dubbo的代码中，我们可以看到一个完整的服务暴露，服务消费的流程。但是内部的流程是怎么样的呢，我们能知道吗？Dubbo的各个组件在什么地方又扮演了什么角色？ Dubbo基本分层在Dubbo的架构里面总体分为了业务层（Biz）、RPC层、Remote三层。继续细分的话可以分为十层，每一层又有自己重要的实现接口如右。 关于每一层的介绍，官网和更多详细书籍都有介绍，这里我用自己的话简述一下。 服务调用流程在了解上面那些组件之后，我们再来看服务调用过程，就能比较清楚的认识到这些组件在整个服务调用流程中具体扮演了什么角色。 服务暴露 我们的服务暴露是在服务提供者中进行的，在框架启动的时候，开始进行整个流程。 首先会初始化我们的API实现接口的实例。 然后通过我们的Proxy组件去调用具体协议（Protocol），也就是加载我们的配置然后进行封装。 将服务端要暴露的接口封装成Invoker（可执行体），然后再封装成Exporter（再次封装是为了接口增强，主要是打开创建一个Netty Server 侦听服务，并接收客户端发来的各种请求）。这两个接口在上面图中也可以知道，其实都是Protocol下的接口。 然后通过Registry注册到注册中心，这便是一个整体的服务暴露过程。 服务调用总流程 （1）在Provider的服务暴露之后，我们的Consumer的调用流程也是从一个Proxy开始，Proxy持有Invoker对象，然后触发invoke调用。 （2）然后获取节点需要通过我们的Cluster，上面组件作用也说过了通过它的作用，主要是负责一些容错。在调用之前会先通过Directory获取所有可以调用的远程服务Invoker列表。如果配置了某些路由规则，比如某个接口只能调用某个节点的那就再过滤一遍 Invoker 列表。 （3）剩下的 Invoker 再通过 LoadBalance 做负载均衡选取一个，然后再通过Filter进行一些计数，限流，处理上下文之类的操作等。 （4）这个时候我们已经拿到了一个实际可用的Invoker，然后会使用Client做数据传输，比如常见的Netty Client。 （5）Codec接口主要是用来处理一些私有协议的构造。构造完成后，进行序列化，然后传输到服务提供者端，服务提供者收到数据包之后，处理协议，反序列化等等操作。 （6）序列化操作完之后我们的请求就被打到线程池去处理，然后查找对应的Exporter（内部持有Invoker），然后将装饰器模式嵌套了一层又一层的Filter剥掉，还原到一个原始的Invoker再到一个真实的服务接口实现类。最后将这个实现类真实调用并原路返回就行。 服务调用流程总结关于服务调用的大概流程基本如上，但是也仅限认识了大概流程。具体每个组件的实现细节，哪些巧妙的地方还是无从而知，所以这些仍是需要我们去学习的地方的。 参考资料 [1] 《深入理解Apache Dubbo与实战》 [2] https://dubbo.apache.org/zh/docs/v2.7/user/quick-start/","categories":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://www.cryface.cn/categories/Dubbo/"}],"tags":[]},{"title":"《模版方法》——设计模式","slug":"设计模式详解之模板方法模式","date":"2020-08-02T14:13:00.000Z","updated":"2021-08-22T16:16:18.693Z","comments":true,"path":"2020/08/02/设计模式详解之模板方法模式/","link":"","permalink":"http://www.cryface.cn/2020/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模式方法是设计模式里面比较好理解的一个设计模式，它的定义是：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模版方法模式的结构很简单，仅仅使用了Java的继承机制，应用十分广泛！ 举例说明同样的，虽然该模式很好理解，但是为了加深理解，我们还是用例子来举例，更容易记住这个模式！ 我们以泡茶这个流程为例来说明。我们可以简单的定义一下泡茶的流程（并非标准流程）： 首先将水煮沸 将我们要泡的茶的茶叶放入杯中 倒入我们的沸水，即可以饮用 这里我们总共有三个流程，不管是泡什么茶叶基本流程都是这样，区别就是在第二步放入的茶叶不同，而其他步骤是一样的。那我们完全可以将其他重复的步骤提取出来复用！下面我们用代码来实现一下可以更好的理解 首先是我们的泡茶抽象类（MakeTea） 123456789101112131415161718192021222324package template;public abstract class MakeTea &#123; //定义为final型，我们的子类是不可以修改泡茶的具体顺序的 public final void make()&#123; boilingWater(); addTeaLeaf(); pourBoilingWater(); &#125;// 首先是我们的将开水煮沸 public void boilingWater()&#123; System.out.println(&quot;首先将开水煮沸！&quot;); &#125;// 加入我们的茶叶，定义为抽象类，由我们的子类来实现加入什么具体的茶叶 public abstract void addTeaLeaf();// 倒入我们的沸水，开始饮用 public void pourBoilingWater()&#123; System.out.println(&quot;倒入我们的沸水，可以饮用了！&quot;); &#125;&#125; 然后我们是去泡一杯铁观音（TieGuanYin）和碧螺春（BiLouChun）试试！ 123456789package template;//铁观音茶public class TieGuanYin extends MakeTea &#123; @Override public void addTeaLeaf() &#123; System.out.println(&quot;加入了铁观音茶叶！&quot;); &#125;&#125; 123456789package template;//碧螺春茶public class BiLouChun extends MakeTea&#123; @Override public void addTeaLeaf() &#123; System.out.println(&quot;加入碧螺春茶叶！&quot;); &#125;&#125; 我们在客户端测试一下 123456789101112131415package template;public class Client &#123; public static void main(String[] args) &#123; //初始化我们的两种茶 MakeTea tieGuanYin = new TieGuanYin(); MakeTea biLouChun = new BiLouChun(); //制作铁观音 tieGuanYin.make(); System.out.println(&quot;------------分割线------------&quot;); //制作碧螺春 biLouChun.make(); &#125;&#125; 控制台结果： 123456789首先将开水煮沸！加入了铁观音茶叶！倒入我们的沸水，可以饮用了！------------分割线------------首先将开水煮沸！加入碧螺春茶叶！倒入我们的沸水，可以饮用了！Process finished with exit code 0 可以看到我们基本都不用重新再去实现原来的步骤，只是在第二步换了我们添加的茶叶，极大提高了我们代码的复用性。但是呢，同时有一个问题，如果我们不想加入茶叶了呢，茶喝多了，想喝点开水。可以看到我们只需要第二步不加入茶叶就是开水了，所有就有了钩子来让用户是否实现抽象方法！ 实现钩子钩子是一种被声明在抽象类中的方法，但只有空的或者默认的实现。这里我们就可以用钩子来实现用户是否选择要加入茶叶，如果不加入茶叶的，就是白开水了。 我们在我们的泡茶抽象类添加钩子方法 12345678910111213141516171819202122232425262728293031package template;public abstract class MakeTea &#123; //定义为final型，我们的子类是不可以修改泡茶的具体顺序的 public final void make()&#123; boilingWater(); if(isAddTeaLeaf())&#123; //如果为true,我们就进行添加茶叶的操作 addTeaLeaf(); &#125; pourBoilingWater(); &#125;// 首先是我们的将开水煮沸 public void boilingWater()&#123; System.out.println(&quot;首先将开水煮沸！&quot;); &#125;// 加入我们的茶叶，定义为抽象类，由我们的子类来实现加入什么具体的茶叶 public abstract void addTeaLeaf();// 倒入我们的沸水，开始饮用 public void pourBoilingWater()&#123; System.out.println(&quot;倒入我们的沸水，可以饮用了！&quot;); &#125;// 钩子方法，判断用户是否要加入茶叶,默认为添加 public boolean isAddTeaLeaf()&#123; return true; &#125;&#125; 然后去实现一杯白开水，然后重写钩子方法，改为false，就可以跳过我们的添加茶叶操作 12345678910111213package template;public class BoiledWater extends MakeTea &#123; @Override public void addTeaLeaf() &#123; //空实现，因为白开水不需要添加茶叶哦！ &#125; @Override public boolean isAddTeaLeaf() &#123; return false; //返回false，表示我们不添加茶叶 &#125;&#125; 然后在我们的客户端是实例化，并不影响我们之前的茶，而且也成功了泡了一杯白开水！ 1234567891011121314151617181920package template;public class Client &#123; public static void main(String[] args) &#123; //初始化我们的两种茶 MakeTea tieGuanYin = new TieGuanYin(); MakeTea biLouChun = new BiLouChun(); //制作铁观音 tieGuanYin.make(); System.out.println(&quot;------------分割线------------&quot;); //制作碧螺春 biLouChun.make(); System.out.println(&quot;------------分割线------------&quot;); //制作一杯白开水 MakeTea boiledWater = new BoiledWater(); boiledWater.make(); &#125;&#125; 控制台输出： 123456789101112首先将开水煮沸！加入了铁观音茶叶！倒入我们的沸水，可以饮用了！------------分割线------------首先将开水煮沸！加入碧螺春茶叶！倒入我们的沸水，可以饮用了！------------分割线------------首先将开水煮沸！倒入我们的沸水，可以饮用了！Process finished with exit code 0 总结模版方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 优点 封装不变部分，扩展可变部分 提取公共部分代码，便于维护 行为由父类控制，子类实现，符合开闭原则 缺点颠倒了我们的设计习惯，一般是抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的食物属性和方法；但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。 应用场景 多个子类共有的方法，并且逻辑基本相同 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。 （补充）模板方法还是父类调用子类方法一个比较好选择，而且在项目中也是符合我们的设计原则的。具体可以参考这一篇【Java面试】父类能调用子类的方法吗？ 参考资料 设计模式之禅（第二版）","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://www.cryface.cn/categories/DesignPattern/"}],"tags":[]},{"title":"《工厂模式》——设计模式","slug":"设计模式详解之工厂模式","date":"2020-08-01T14:13:00.000Z","updated":"2021-08-22T16:16:02.828Z","comments":true,"path":"2020/08/01/设计模式详解之工厂模式/","link":"","permalink":"http://www.cryface.cn/2020/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工厂模式顾名思义，工厂就是用来统一创建产品的。我们的工厂根据产品是具体产品还是工厂可以分为简单工厂模式和工厂方法模式，根据抽象程度可以分为工厂方法模式和抽象工厂模式。工厂模式的核心本质是： 实例化对象不使用new，用工厂方法替代 将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。 工厂模式在我们的场景中用到的还是比较多的： JDK中Calendar的getInstance方法 JDBC中的Connection对象的获取 Spring中IOC容器创建管理bean对象 反射中Class对象的newInstance方法 简单工厂模式（静态工厂模式）用来生产同一等级结构中的任意产品，只需要对工厂传递需要创建对象的类型即可。这里我们以计算器为来讲解该模式： 首先是我们的运算统一接口（Operation） 123456package simplefactory;//运算统一接口public interface Operation &#123; void operate();&#125; 加法操作： 12345678package simplefactory;public class AddOperation implements Operation&#123; @Override public void operate() &#123; System.out.println(&quot;进行了加法操作！&quot;); &#125;&#125; 减法操作： 12345678package simplefactory;public class SubOperation implements Operation&#123; @Override public void operate() &#123; System.out.println(&quot;进行了减法操作！&quot;); &#125;&#125; 我们定义一个简单工厂来代替我们创建对象： 12345678910111213141516package simplefactory;public class OpetationFactory &#123; public static Operation createOperate(String operate)&#123; Operation oper = null; switch (operate)&#123; case &quot;加法&quot;: oper = new AddOperation(); break; case &quot;减法&quot;: oper = new SubOperation(); break; &#125; return oper; &#125;&#125; 我们在客户端进行实践一下： 1234567891011121314151617package simplefactory;public class Client &#123; public static void main(String[] args) &#123; //第一个操作执行加法操作 Operation operation1 = OpetationFactory.createOperate(&quot;加法&quot;); operation1.operate(); //第二个操作执行减法操作 Operation operation2 = OpetationFactory.createOperate(&quot;减法&quot;); operation2.operate(); &#125;&#125;//演示结果//进行了加法操作！//进行了减法操作！ 这样我们就不需要创建对象这个过程，只需要告诉工厂我们需要什么对象就行，省略了很多的麻烦。但是如果我们这个时候要增加一个要求怎么办呢？我们先需要实现操作统一接口，然后再在工厂里面增加我们的新操作的分支，比如我们增加一个乘法的操作的话。 实现接口： 12345678package simplefactory;public class MulOperation implements Operation&#123; @Override public void operate() &#123; System.out.println(&quot;进行了乘法操作！&quot;); &#125;&#125; 在工厂里面添加分支： 12345678910111213141516171819package simplefactory;public class OpetationFactory &#123; public static Operation createOperate(String operate)&#123; Operation oper = null; switch (operate)&#123; case &quot;加法&quot;: oper = new AddOperation(); break; case &quot;减法&quot;: oper = new SubOperation(); break; case &quot;乘法&quot;: //新加的乘法操作分支 oper = new MulOperation(); break; &#125; return oper; &#125;&#125; 很显然，这样的操作如果在工程量特别大的去修改代码是特别麻烦的，而且主要的是，这不符合我们的开闭原则（对修改关闭，对扩展开放）。 所以我们是有办法来关闭修改操作的——反射，下面代码我们对创建工厂进行重构之后（T表示只要实现了Operaton都可以当作接口，是JDK1.5之后的新特性——泛型，减少了对象之间的转换） 1234567891011121314package simplefactory;public class OpetationFactory &#123; public static &lt;T extends Operation&gt; T createOperate(Class&lt;T&gt; c)&#123; Operation oper = null; try&#123; oper = (T) Class.forName(c.getName()).newInstance(); &#125;catch (Exception e)&#123; System.out.println(&quot;没有该操作！&quot;); &#125; return (T) oper; &#125;&#125; 这个时候如果需要添加新的操作的时候，我们只需要创建实现类即可，然后在客户端就可以使用了，关闭了对创建工厂的修改。符合了我们的开闭原则。 12345678910111213141516package simplefactory;public class Client &#123; public static void main(String[] args) &#123; //第一个操作执行加法操作 Operation operation1 = OpetationFactory.createOperate(AddOperation.class); operation1.operate(); //第二个操作执行减法操作 Operation operation2 = OpetationFactory.createOperate(SubOperation.class); operation2.operate(); //第三个操作为我们的乘法操作 Operation operation3 = OpetationFactory.createOperate(MulOperation.class); operation3.operate(); &#125;&#125; 控制台结果： 12345进行了加法操作！进行了减法操作！进行了乘法操作！Process finished with exit code 0 对简单工厂模式的优化还有其他方式，可以看看这篇博客Java简单工厂模式以及来自lambda的优化 工厂方法模式工厂方法是对简单工厂模式进一步的修改，是在不修改已有类的前提下，通过增加新的工厂类实现扩展。可以说是对没有优化前的简单工厂模式的一种优化，贴合了开闭原则。 我们通过UML图可以清晰认识： 我们操作的接口和实现类不变，只不过我们把原来在一个工厂生产对象的的工厂变成了每一个实现类都有自己的生产工厂了。这样我们如果需要再添加新的操作的话，我们只需要添加一个实现类和一个工厂就行了，非常符合我们的开闭原则。 定义我们工厂统一接口的抽象类： 123456package factorymethod;//工厂统一接口public interface OperationFactory &#123; Operation doingOperate();&#125; 然后是我们加法的工厂： 12345678package factorymethod;public class AddOperationFactory implements OperationFactory&#123; @Override public Operation doingOperate() &#123; return new AddOperation(); &#125;&#125; 减法的工厂： 12345678package factorymethod;public class SubOperationFactory implements OperationFactory &#123; @Override public Operation doingOperate() &#123; return new SubOperation(); &#125;&#125; 我们的客户端： 123456789101112131415package factorymethod;public class Client &#123; public static void main(String[] args) &#123; OperationFactory factoryAdd = new AddOperationFactory(); OperationFactory factorySub = new SubOperationFactory(); // 第一个操作为加法操作 Operation operation1 = factoryAdd.doingOperate(); operation1.operate(); //输出：进行了加法操作 // 第二个操作为减法操作 Operation operation2 = factorySub.doingOperate(); operation2.operate(); //输出：进行了减法操作 &#125;&#125; 抽象工厂模式抽象工厂总的来说，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。就是围绕一个超级工厂来创建其他工厂，该超级工厂又称为其他工厂的工厂。 这里我再以计算器的操作来举例有点不合适，网上最多的就是手机和电脑品牌的举例。因为可以比较清晰理解抽象工厂，我们不是增加一个产品，而是增加一个产品族。如果我们只是单一的一个手机可以使用上面的工厂方法来创建，但是如果多了一个电脑呢？可以复制一下手机工厂方法的代码，修改一下名字就可以使用，但是这很明显的就是重复代码了吧。我们是无论如何也不能忍受的，所以就有了抽象工厂模式。 首先我们先来定义一个手机的统一接口 12345package abstractfactory;public interface Phone &#123; void make();&#125; 实现华为和小米的Phone实现类： 12345678package abstractfactory;public class HuaWeiPhone implements Phone &#123; @Override public void makePhone() &#123; System.out.println(&quot;生产的是华为手机！&quot;); &#125;&#125; 12345678package abstractfactory;public class XiaoMiPhone implements Phone&#123; @Override public void makePhone() &#123; System.out.println(&quot;生产的是小米手机！&quot;); &#125;&#125; 定义一个电脑的统一接口 12345package abstractfactory;public interface Computer &#123; void makeComputer();&#125; 实现华为和小米的Computer实现类： 12345678package abstractfactory;public class HuaWeiComputer implements Computer &#123; @Override public void makeComputer() &#123; System.out.println(&quot;生产的是华为电脑！&quot;); &#125;&#125; 12345678package abstractfactory;public class XiaoMiComputer implements Computer&#123; @Override public void makeComputer() &#123; System.out.println(&quot;生产的是小米电脑！&quot;); &#125;&#125; 然后就是我们的抽象工厂了，因为我们不管是小米工厂还是华为工厂都需要生产手机和电脑，所以我们可以说这就是一个产品族。 123456package abstractfactory;public interface AbstractFactory &#123; Phone makePhone(); Computer makeComputer();&#125; 然后我们实现抽象工厂的接口，有小米工厂和华为工厂 12345678910111213package abstractfactory;public class XiaoMiFactory implements AbstractFactory &#123; @Override public Phone makePhone() &#123; return new XiaoMiPhone(); &#125; @Override public Computer makeComputer() &#123; return new XiaoMiComputer(); &#125;&#125; 12345678910111213package abstractfactory;public class HuaWeiFactory implements AbstractFactory &#123; @Override public Phone makePhone() &#123; return new HuaWeiPhone(); &#125; @Override public Computer makeComputer() &#123; return new HuaWeiComputer(); &#125;&#125; 在我们的客户端使用： 1234567891011121314151617package abstractfactory;public class Client &#123; public static void main(String[] args) &#123; AbstractFactory xiaoMiFactory = new XiaoMiFactory(); Phone xiaoMiPhone = xiaoMiFactory.makePhone(); xiaoMiPhone.makePhone(); //输出：生产的是小米手机！ Computer xiaoMiComputer = xiaoMiFactory.makeComputer(); xiaoMiComputer.makeComputer(); //输出：生产的是小米电脑！ AbstractFactory huaWeiFactory = new HuaWeiFactory(); Phone huaWeiPhone = huaWeiFactory.makePhone(); huaWeiPhone.makePhone(); // 输出：生产的是华为手机！ Computer huaWeiComputer = huaWeiFactory.makeComputer(); huaWeiComputer.makeComputer(); //输出：生产的是华为电脑！ &#125;&#125; 关于我们的抽象工厂的适用场景： 客户端不依赖产品类实例如何被创建，实现等细节 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码 提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现 优点： 具体产品在应用层的代码隔离，无需关心创建的细节 将一个系列的产品统一到一起创建 缺点： 规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难（注意是产品扩展族而不是产品等级。比如我们这个时候要添加一个一加品牌，只要拥有相同的产品簇，我们只要实现产品接口有实现类然后添加一个工厂生产实例就可以实现。可以说是横向扩展，符合开闭原则。但是如果这时候要添加一个充电宝的产品，就需要修改里面的大量代码，极其复杂，所以需要在刚开始就要设计好。） 增加了系统的抽象性和理解难度 总结工厂模式的三种模式有各自的应用场景，无论哪种模式，只要能解决问题就是好用的。 参考资料 《大话设计模式》 《设计模式之禅（第二版）》","categories":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://www.cryface.cn/categories/DesignPattern/"}],"tags":[]}],"categories":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://www.cryface.cn/categories/Dubbo/"},{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://www.cryface.cn/categories/DesignPattern/"}],"tags":[]}